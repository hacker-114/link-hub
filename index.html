<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Chromebook Utilities Portal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Styles -->
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" />
</head>
<body>
  <!-- Starfield -->
  <div id="starfield"></div>

  <!-- Title -->
  <h1 id="title">üìÅ Chromebook Utilities</h1>
  <h3>This collection was created by S-PScripts! Check out the source 
    <a href="https://github.com/S-PScripts/chromebook-utilities" target="_blank">here</a>
  </h3>
  <h4>If nothing loads, use the link above or download the 
    <a href="chromebook-utilities-sept2025.zip">repo</a>
  </h4>

  <!-- Search -->
  <div id="searchdiv">
    <input type="text" name="search" id="search" placeholder="Search files">
    <span class="material-symbols-outlined">search</span>
  </div>

  <!-- Status banner -->
  <div id="status" style="display:none;"></div>

  <!-- File tree -->
  <div id="file-tree">Loading...</div>

  <!-- Feedback -->
  <div id="feedback-button">
    <a href="/form/index.html" target="_blank">Feedback</a>
  </div>

  <!-- Back -->
  <button id="back" onclick="window.open('/ppfn-static/','_self')">
    <span class="material-symbols-outlined">arrow_back</span>
  </button>

  <!-- Starfield script -->
  <script>
    const starCount = 500;
    const starfield = document.getElementById('starfield');
    function random(min, max) { return Math.random() * (max - min) + min; }
    for (let i = 0; i < starCount; i++) {
      const star = document.createElement('div');
      star.classList.add('star');
      const size = random(0.5, 3);
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;
      star.style.top = `${random(0, window.innerHeight)}px`;
      star.style.left = `${random(0, window.innerWidth)}px`;
      star.style.opacity = Math.random() * 0.8 + 0.2;
      star.style.animationDuration = `${random(3, 8)}s`;
      starfield.appendChild(star);
    }
  </script>

  <!-- Unified tree + search -->
  <script>
    const user = "S-PScripts";
    const repo = "chromebook-utilities";
    const branch = "main";
    const treesApi = `https://api.github.com/repos/${user}/${repo}/git/trees/${branch}?recursive=1`;

    // Link mode: 'origin' | 'raw' | 'blob'
    const linkMode = 'raw';

    function showStatus(message) {
      const status = document.getElementById('status');
      status.style.display = 'block';
      status.textContent = message;
    }

    function buildLink(path) {
      // Encode path segments safely
      const safePath = path.split('/').map(encodeURIComponent).join('/');
      if (linkMode === 'origin') {
        return `${window.location.origin}/${safePath}`;
      } else if (linkMode === 'raw') {
        return `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${safePath}`;
      } else {
        return `https://github.com/${user}/${repo}/blob/${branch}/${safePath}`;
      }
    }

    function buildTreeDom(items) {
      // items: array of {path, type} from Git trees
      // Build nested UL structure
      const root = {};
      for (const item of items) {
        const parts = item.path.split('/');
        let cur = root;
        for (let i = 0; i < parts.length; i++) {
          const key = parts[i];
          const isLeaf = i === parts.length - 1;
          cur.children = cur.children || {};
          cur.children[key] = cur.children[key] || {};
          cur.children[key].__type = isLeaf ? item.type : 'tree';
        }
      }

      function makeUl(node, prefix = "") {
        const ul = document.createElement('ul');
        const keys = Object.keys(node.children || {}).sort((a,b)=>a.localeCompare(b));
        for (const key of keys) {
          const child = node.children[key];
          const li = document.createElement('li');
          const childPath = prefix ? `${prefix}/${key}` : key;

          if (child.__type === 'tree') {
            li.innerHTML = `<strong>üìÅ ${key}</strong>`;
            li.appendChild(makeUl(child, childPath));
          } else {
            const href = buildLink(childPath);
            // Use encodeURI for the visible text; href already encoded
            li.innerHTML = `<a href="${href}" target="_blank">üìÑ ${encodeURI(key)}</a>`;
          }
          ul.appendChild(li);
        }
        if (!ul.childNodes.length) {
          const empty = document.createElement('li');
          empty.textContent = "(empty)";
          ul.appendChild(empty);
        }
        return ul;
      }

      return makeUl(root);
    }

    function renderTree(container, dom) {
      container.innerHTML = "";
      container.appendChild(dom);
    }

    function flattenFiles(items) {
      return items.filter(i => i.type === 'blob').map(i => ({
        name: i.path.split('/').pop(),
        path: i.path,
        href: buildLink(i.path)
      }));
    }

    function renderSearchResults(container, files, query) {
      const q = query.trim().toLowerCase();
      if (!q) {
        // Rebuild full tree if query cleared
        renderTree(container, buildTreeDom(window.__allItems));
        return;
      }
      const ul = document.createElement('ul');
      const matches = files.filter(f => f.name.toLowerCase().includes(q) || f.path.toLowerCase().includes(q));
      matches.sort((a,b)=>a.path.localeCompare(b.path));
      for (const f of matches) {
        const li = document.createElement('li');
        li.innerHTML = `<a href="${f.href}" target="_blank">üìÑ ${encodeURI(f.path)}</a>`;
        ul.appendChild(li);
      }
      if (!ul.childNodes.length) {
        const li = document.createElement('li');
        li.textContent = "No matches.";
        ul.appendChild(li);
      }
      container.innerHTML = "";
      container.appendChild(ul);
    }

    async function loadRepo() {
      const container = document.getElementById("file-tree");
      try {
        const res = await fetch(treesApi);
        if (!res.ok) throw new Error(`GitHub trees error: ${res.status}`);
        const data = await res.json();

        // data.tree is an array of { path, type: 'blob' | 'tree' }
        const items = data.tree || [];
        window.__allItems = items;

        const dom = buildTreeDom(items);
        renderTree(container, dom);

        const files = flattenFiles(items);
        const searchInput = document.getElementById('search');
        searchInput.addEventListener('input', () => renderSearchResults(container, files, searchInput.value));
      } catch (e) {
        showStatus("Could not load full repo from GitHub. Showing minimal fallback.");
        // Minimal hard fallback
        const ul = document.createElement('ul');
        ['404.html','Alternatives/Fandom Alternative Links.txt','Alternatives/Github Alternative Links.txt','Alternatives/Google Workspace Alt Links.txt']
          .forEach(path => {
            const li = document.createElement('li');
            li.innerHTML = `<a href="${buildLink(path)}" target="_blank">üìÑ ${encodeURI(path)}</a>`;
            ul.appendChild(li);
          });
        container.innerHTML = "";
        container.appendChild(ul);
      }
    }

    loadRepo();
  </script>
</body>
</html>
